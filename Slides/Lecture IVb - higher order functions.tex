\documentclass{beamer}
\usetheme[hideothersubsections]{HRTheme}
\usepackage{beamerthemeHRTheme}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[space]{grffile}

\title{Functions}

\author{TEAM INFDEV}

\institute{Hogeschool Rotterdam \\ 
Rotterdam, Netherlands}

\date{}

\begin{document}
\maketitle

\SlideSection{Introduction}
\SlideSubSection{Motivation}
\begin{slide}{
\item Sometimes simple functions are not flexible enough
\item We might have similar algorithms that are ``not quite'' the same
\item For example, consider adding or multiplying all elements of a list together
\begin{itemize}
\item \textbf{``Consider'' here actually means do it on paper and then a volunteer comes implement it at the lecturer's PC}
\end{itemize}
}\end{slide}

\SlideSection{Higher order function}
\SlideSubSection{Idea}
\begin{slide}{
\item Functions may also take and return other functions as parameters
\begin{itemize}
\item These are then called \textbf{higher order functions} (HOF's)\footnote{\pause \textbf{Higher order} because parameters are not concrete values but rather computations, which are higher wrt the floors of the Ivory Tower}
\end{itemize}
\item This lets us specify a function where some instructions are not fixed
\item By passing other functions as parameters we literally create ``customizable algorithms''
}\end{slide}

\SlideSubSection{Example}
\begin{slide}{
\item As an example, consider the case of combining two values together
\item We do not care how, as long as they are combined according to some criterion
\item The criterion is given as an input function
}\end{slide}

\begin{frame}[fragile]{HOF's}
\begin{codewithblock}{\item What do we know about \texttt{x} and \texttt{y}? \item Do we even care?}
def combine(op,x,y):
  return op(x,y)
\end{codewithblock}
\end{frame}

\begin{slide}{
\item A function such as \texttt{combine} can be used by providing another function as the first parameter
\item As long as the function will work correctly on the second and third parameters
}\end{slide}

\begin{frame}[fragile]{HOF's}
\begin{codewithblock}{\item \textbf{What does this code do?} \pause \item Prints \texttt{30}, \texttt{200}, \texttt{-10}}
def combine(op,x,y):
  return op(x,y)

def plus(x,y): return x + y
def times(x,y): return x * y
def minus(x,y): return x - y
  
print(combine(plus, 10, 20))
print(combine(times, 10, 20))
print(combine(minus, 10, 20))
\end{codewithblock}
\end{frame}

\begin{slide}{
\item We can use \texttt{combine} on any data types we want
\item For example, strings
}\end{slide}

\begin{frame}[fragile]{HOF's}
\begin{codewithblock}{\item \textbf{What does this code do?} \pause \item Prints \texttt{1020}, \texttt{200}, \texttt{-10}}
def combine(op,x,y):
  return op(x,y)

def plus(x,y): return x + y
def times(x,y): return x * y
def minus(x,y): return x - y
  
print(combine(plus, "10", "20"))
print(combine(times, 10, 20))
print(combine(minus, 10, 20))
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{HOF's}
\begin{lstlisting}
def combine(op,x,y):
  return op(x,y)

def plus(x,y): return x + y
def times(x,y): return x * y
def minus(x,y): return x - y
  
print(combine(plus, "10", "20"))
print(combine(times, 10, 20))
print(combine(minus, 10, 20))
\end{lstlisting}

\textbf{What do stack and heap look like from inside a call to \texttt{combine?}}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|}
{PC & combine & PC & op & x & y}
{8 & nil & 2 & ref(plus) & "10" & "20"}
{|c|}{}{}
\end{memorytable} \ \\

or 

\begin{memorytable}
{|c|c|c|c|c|c|}
{PC & combine & PC & op & x & y}
{8 & nil & 2 & ref(times) & 10 & 20}
{|c|}{}{}
\end{memorytable} \ \\

\end{frame}

\SlideSubSection{Lambda-syntax function definition}
\begin{slide}{
\item Defining functions such as \texttt{plus}, \texttt{times}, and \texttt{minus} is cumbersome
\item After all, we already have symbols for them: \texttt{(+)}, \texttt{(*)}, and \texttt{(-)}
\item Repetition and duplication of code is never good
}\end{slide}

\begin{slide}{
\item Python (version at least 3) offers facilities for the inline definition of short functions
\item The syntax fits one line and requires no newlines
\item \texttt{lambda <<paramters>>: <<result>>}
\begin{itemize}
\item \texttt{<<parameters>>} is a list of comma-separated parameters
\item \texttt{<<result>>} is the expression that is returned
\end{itemize}
\item For example: \texttt{lambda x,y: x+y}
}\end{slide}

\begin{frame}[fragile]{HOF's}
\begin{codewithblock}{\item \textbf{What does this code do?} \pause \item Prints \texttt{1020}, \texttt{200}, \texttt{-10} \item Does not require the extra function definitions}
def combine(op,x,y):
  return op(x,y)

print(combine((lambda x,y: x+y), "10", "20"))
print(combine((lambda x,y: x*y), 10, 20))
print(combine((lambda x,y: x-y), 10, 20))
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{HOF's}
\begin{lstlisting}
def combine(op,x,y):
  return op(x,y)

print(combine((lambda x,y: x+y), "10", "20"))
print(combine((lambda x,y: x*y), 10, 20))
print(combine((lambda x,y: x-y), 10, 20))
\end{lstlisting}

\textbf{What do stack and heap look like from inside a call to \texttt{combine?}}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|}
{PC & combine & PC & op & x & y}
{4 & nil & 2 & ref(0) & "10" & "20"}
{|c|}{0}{lambda x,y: x+y}
\end{memorytable} \ \\

or 

\begin{memorytable}
{|c|c|c|c|c|c|}
{PC & combine & PC & op & x & y}
{5 & nil & 2 & ref(1) & 10 & 20}
{|c|c|}{0 & 1}{lambda x,y: x+y & lambda x,y: x*y}
\end{memorytable} \ \\
\end{frame}

\begin{slide}{
\item We can also return a function from a function
\item For example, to dynamically choose an operation
\item This makes code very expressive and flexible, but also potentially much harder to read
\item Use with caution!
}\end{slide}

\begin{frame}[fragile]{HOF's}
\begin{codewithblock}{\item \textbf{What does this code do?} \pause \item Chooses the function based on \texttt{input} that will \texttt{combine} \texttt{10} and \texttt{20}}
def combine(op,x,y):
  return op(x,y)

def choose_operation():
  i = input("Choose an operation between +, -, or *")
  if i == "+":
    return lambda x,y: x+y
  elif i == "-":
    return lambda x,y: x-y
  else:
    return lambda x,y: x*y
print(combine(choose_operation(), 10, 20))
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{HOF's}
\begin{lstlisting}
def combine(op,x,y):
  return op(x,y)

def choose_operation():
  i = input("Choose an operation between +, -, or *")
  if i == "+":
    return lambda x,y: x+y
  elif i == "-":
    return lambda x,y: x-y
  else:
    return lambda x,y: x*y
print(combine(choose_operation(), 10, 20))
\end{lstlisting}

\textbf{What do stack and heap look like after \texttt{choose\_operation} terminates?}

\pause

\begin{memorytable}
{|c|c|}
{PC & choose\_operation}
{12 & ref(0)}
{|c|}{0}{lambda x,y: x+y}
\end{memorytable} \ \\
\end{frame}

\SlideSection{Assignments}
\SlideSubSection{Build and test, on paper...}
\begin{slide}{
\item A hof \texttt{map} that transforms all elements of a list:
\begin{itemize}
\item \texttt{map(lambda x: x + 10, Node(1,Node(2,Node(3,Empty)))) -> Node(11,Node(12,Node(13,Empty)))}
\end{itemize}
\item A hof \texttt{filter} that removes elements from a list:
\begin{itemize}
\item \texttt{filter(lambda x: x \% 2 == 0, Node(1,Node(2,Node(3,Empty)))) -> Node(2,Empty)}
\end{itemize}
\item A hof \texttt{reduce} that condenses a list into a single value:
\begin{itemize}
\item \texttt{reduce(lambda x,y: x + y, Node(1,Node(2,Node(3,Empty)))) -> 6}
\end{itemize}
}\end{slide}

\SlideSection{Conclusion}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item Often, user code needs to perform operations that are similar to each other
\item Through the mechanism of function definition, we can recycle code
\item Functions can encode algorithms in many way
\begin{itemize}
\item Simple code abstractions to avoid repetition
\item Recursive problems
\item Algorithms with ``holes'' given as higher order parameters
\item Algorithms that return other algorithms as higher order results
\end{itemize}
}\end{slide}

\begin{thankyou}
\end{thankyou}

\end{document}

\begin{slide}{
\item ...
}\end{slide}

\begin{frame}[fragile]
\begin{lstlisting}
...
\end{lstlisting}
\end{frame}
