\documentclass{beamer}
\usetheme[hideothersubsections]{HRTheme}
\usepackage{beamerthemeHRTheme}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[space]{grffile}

\title{Classes as data structures with methods}

\author{TEAM INFDEV}

\institute{Hogeschool Rotterdam \\ 
Rotterdam, Netherlands}

\date{}

\begin{document}
\maketitle

\SlideSection{Introduction}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item In this lecture we will ``close the circle'' of data structures and functions
\item We will show how it is possible to form a new, even more powerful abstraction
\item We will define \textbf{classes} as the joining of functions and data structures
}\end{slide}

\SlideSection{Problem discussion}
\SlideSubSection{Introduction}
\begin{slide}{
\item Functions on lists always take a list as input
\item This list is understood as the main \textbf{subject} of the computation
\item We would like to create a stronger visual and semantic link between the subject of a computation and the computation itself
}\end{slide}

\SlideSubSection{Examples}
\begin{slide}{
\item \texttt{length} of a list
\item \texttt{sum} of a list
\item \texttt{find} in a list a given element
\item \texttt{map} of a list wrt some transformation
\item ...
}\end{slide}

\SlideSection{General idea}
\SlideSubSection{Introduction}
\begin{slide}{
\item To solve the problem, we will create \texttt{classes}
\item A \texttt{class} is the union of a data structures and its characterizing functions
\item The functions inside a class are known as \texttt{methods}
}\end{slide}

\SlideSubSection{Blueprint of a class}
\begin{slide}{
\item What are the fundamental attributes?
\item What properties do the attributes have (relationships, etc.)?
\item What are the fundamental methods of the class?
\item What properties do the attributes have (relationships, returned values, etc.)?
}\end{slide}

\begin{frame}[fragile]{The blueprint of the list class (\textbf{THIS IS NOT CODE!})}
\begin{lstlisting}
Abstraction List =
  the list may be Empty, with
    no attributes
    IsEmpty() method returns True
    Map(f) method returns the empty list
    Filter(p) method returns the empty list
    ...
    
  the list may be a Node
    head attribute (the value of the element of this node)
    tail attribute (the rest of the list)
    IsEmpty() method returns False
    Map(f) method returns the the transformed list wrt function f
    Filter(p) method returns the list with only elements respecting p
    ...
\end{lstlisting}
\end{frame}

\SlideSubSection{Design of a class}
\begin{slide}{
\item The hardest part of building a class is its design
\item How do we build a reasonable class?
\item What is a bad implementation?
}\end{slide}

\begin{slide}{
\item The same logic that applies to the design of functions applies to classes
\item \textbf{Encapsulation}\footnote{Also called \textbf{information hiding}} is the central property of both
\item A class is well encapsulated if 
\begin{itemize}
\item it offers a clear interaction surface by not exposing its internals in a dangerous way
\item it is a cohesive unit that offers a single, clearly defined set of related services
\end{itemize}
}\end{slide}

\begin{slide}{
\item Thanks to \textbf{encapsulation}, a program can be built as a series of independent units
\item These units are \textbf{loosely coupled}, in the sense that a change in the implementation (but not the methods offered) of one unit does not break the others\footnote{Think about a faster implementation, for example.}
}\end{slide}

\begin{slide}{
\item A bad example would be a \texttt{ListOrPlayer} class which contains a list or a player, with methods and fields such as:
\begin{itemize}
\item \texttt{IsList}, \texttt{IsPlayer}
\item \texttt{Name}, \texttt{Score}, \texttt{Weapon}, ...
\item \texttt{Length}, \texttt{Map}, \texttt{Filter}, ...
\end{itemize}
\item Why is it a bad example?
\pause
\item Because it is not a clear unit, but two at the same time
}\end{slide}

\begin{slide}{
\item A bad example would be a \texttt{List} which \textit{leaks} parts of implementation
\item A ``leaky'' list would have strange methods that rely on specific external usage patterns like:
\begin{itemize}
\item \texttt{ComputeFirstPartOfLength} that computes the length of the first half of the list
\item \texttt{ComputeSecondPartOfLength} that computes the length of the second half of the list
\item \texttt{GetLengthParts} that returns the lengths of the two half lists
\end{itemize}
\item Why is it a bad example?
\pause
\item Because the implementation of length only happens if the user of the list calls it properly
}\end{slide}

\SlideSection{Technical details}
\SlideSubSection{Introduction}
\begin{slide}{
\item How is this done in Python?
}\end{slide}

\SlideSubSection{Syntax and semantics}
\begin{slide}{
\item How is this done in Python?
}\end{slide}

\SlideSubSection{Examples}
\begin{slide}{
\item Example instances of the solution
\item Code samples
\item Steps in the memory model and accompanying discussion in class
}\end{slide}

\SlideSection{Conclusion}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item What problem did we solve today, and how?
}\end{slide}

\begin{frame}{This is it!}
\center
\fontsize{18pt}{7.2}\selectfont
The best of luck, and thanks for the attention!
\end{frame}

\end{document}

\begin{slide}{
\item ...
}\end{slide}

\begin{frame}[fragile]
\begin{lstlisting}
...
\end{lstlisting}
\end{frame}
